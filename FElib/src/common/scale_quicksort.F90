!-------------------------------------------------------------------------------
! Warning: This file was generated from common/scale_quicksort.F90.erb.
!          Do not edit this file.
!-------------------------------------------------------------------------------
#include "scaleFElib.h"
module scale_quicksort
  !-----------------------------------------------------------------------------
  !
  !++ used modules
  !
  use scale_precision

  !-----------------------------------------------------------------------------
  implicit none
  private

  !-----------------------------------------------------------------------------
  !
  !++ Public procedure
  !  

  interface QUICKSORT_exec_with_idx
    module procedure QUICKSORT_exec_with_idx_int
    module procedure QUICKSORT_exec_with_idx_real_RP
  end interface QUICKSORT_exec_with_idx
  
  public :: QUICKSORT_exec_with_idx

contains
  
  !- private routines -------------------------------------

  subroutine QUICKSORT_exec_with_idx_int( npoints, val, indx )
    integer, intent(in) :: npoints
    integer, intent(inout) :: val(npoints)
    integer, intent(inout) :: indx(npoints)

    !-------------------------------
    call quicksort_core_int(val, indx, 1, npoints)
  end subroutine QUICKSORT_exec_with_idx_int
  subroutine QUICKSORT_exec_with_idx_real_RP( npoints, val, indx )
    integer, intent(in) :: npoints
    real(RP), intent(inout) :: val(npoints)
    integer, intent(inout) :: indx(npoints)

    !-------------------------------
    call quicksort_core_real_RP(val, indx, 1, npoints)
  end subroutine QUICKSORT_exec_with_idx_real_RP

  !-- private ------------------------------------------------

  recursive subroutine quicksort_core_int(key, ind, first, last)
    integer, intent(inout) :: key(:)
    integer, intent(inout) :: ind(:)
    integer, intent(in) :: first, last

    integer :: x, tmp, i, j
    !-------------------------------

    x = key( (first + last)/2 )
    i = first
    j = last

    do 
      do while ( key(i) < x )
        i = i + 1
      end do
      do while ( x < key(j) )
        j = j - 1
      end do
      if ( i >= j ) exit
      
      ! swap
      tmp = key(i); key(i) = key(j); key(j) = tmp
      tmp = ind(i); ind(i) = ind(j); ind(j) = tmp

      i = i + 1; j = j - 1
    end do

    if ( first < i-1 ) call quicksort_core_int(key, ind, first, i-1)
    if ( j+1 < last )  call quicksort_core_int(key, ind, j+1, last)

  end subroutine quicksort_core_int
  recursive subroutine quicksort_core_real_RP(key, ind, first, last)
    real(RP), intent(inout) :: key(:)
    integer, intent(inout) :: ind(:)
    integer, intent(in) :: first, last

    integer :: x, tmp, i, j
    !-------------------------------

    x = key( (first + last)/2 )
    i = first
    j = last

    do 
      do while ( key(i) < x )
        i = i + 1
      end do
      do while ( x < key(j) )
        j = j - 1
      end do
      if ( i >= j ) exit
      
      ! swap
      tmp = key(i); key(i) = key(j); key(j) = tmp
      tmp = ind(i); ind(i) = ind(j); ind(j) = tmp

      i = i + 1; j = j - 1
    end do

    if ( first < i-1 ) call quicksort_core_real_RP(key, ind, first, i-1)
    if ( j+1 < last )  call quicksort_core_real_RP(key, ind, j+1, last)

  end subroutine quicksort_core_real_RP
end module scale_quicksort
